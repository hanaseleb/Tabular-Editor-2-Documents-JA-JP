ベストプラクティスアナライザ
注意
Best Practice AnalyzerはTabular Editor v.2.8.1で全面的に刷新されたため、この記事に掲載されている情報やスクリーンショットの一部は古くなっています。ダイナミックLINQ（ルール式）に関する情報は最新のものです。

この素晴らしい提案に触発され、Tabular Editorの新機能であるBest Practice Analyzer (BPA)を発表します。ツールメニューから「Best Practice Analyzer...」をクリックすると、次のようなウィンドウが表示されます（BPAウィンドウを開いたまま、メインウィンドウでモデルの作業を続けることができます）。

https://cloud.githubusercontent.com/assets/8976200/25298153/07cb3ae0-26f3-11e7-84cb-1c27a5911560.png

BPAでは、モデルのメタデータにルールを定義して、SSAS Tabularでの開発時に特定の慣習やベストプラクティスを奨励することができます。

上のリストのルールをクリックすると、そのルールの条件を満たすすべてのオブジェクトが下のリストに表示されます。

https://cloud.githubusercontent.com/assets/8976200/25298226/9c036214-26f3-11e7-97ea-03ef82366eb5.png

リスト内のオブジェクトをダブルクリックすると、タブラー・エディタのメインウィンドウにフォーカスが戻り、エクスプローラー・ツリーでオブジェクトが選択されます（「Go to object...」）。また、あるルールを完全に無視したり（ルールリストのチェックマークを外すことでもできます）、特定のオブジェクトに対してのみ無視するように指定することもできます。無視は、Model.bimファイルのメタデータアノテーションに保存されます。

新しいルールを作成するには、Tabular EditorにTabular Modelが読み込まれている状態で、「Add rule...」をクリックします。すると新しいウィンドウが開き、ルールの名前や説明、ルールの条件を指定することができます。

https://cloud.githubusercontent.com/assets/8976200/25298330/4178cbe4-26f4-11e7-97ee-d80c1dbc54ed.png

ビジュアルなルールビルダーは後のリリースで予定されています。現時点では、ドロップダウンで指定されたオブジェクトのタイプのすべてのプロパティにアクセスすることができるダイナミックLINQ式を使用して、ルールの条件を指定します。ルールが選択されると、その条件を満たすすべてのオブジェクトがBPA UIに表示されます。

デフォルトでは、この方法で作成されたルールは、Tabular Editor で「保存」をクリックすると、モデルオブジェクトのメタデータアノテーションに追加され、Model.bim ファイルまたは接続されたデータベースに保存されます。モデルにローカルに保存されているルールを「グローバル」ルールに昇格させることができます。グローバルルールは、%AppData%Local\TabularEditorフォルダ内の「BPARules.json」というファイルに保存されます。BPARules.jsonを%ProgramData%\TabularEditorフォルダに置いて、マシン上のすべてのユーザーがルールを利用できるようにすることもできます。

ルールのIDは常に一意でなければならないことに注意してください。モデルメタデータ内のルールが、%AppData%または%ProgramData%フォルダ内のルールと同じIDを持っている場合、優先順位は以下の通りです。

モデルにローカルに保存されているルール
AppData%%Local フォルダに格納されているルール
ProgramData% フォルダに格納されているルール
ルール式のサンプル
このセクションでは、ルールの定義に使用できるDynamic LINQ式の例をいくつか紹介します。ルール式エディタに入力された式は、フォーカスがテキストボックスから離れるたびに評価され、構文エラーがあれば画面の上部に表示されます。

https://cloud.githubusercontent.com/assets/8976200/25380170/9f01634e-29af-11e7-952e-e10a1f28df32.png

ルール式は、TOM内のオブジェクトのパブリックプロパティにアクセスすることができます。そのタイプのオブジェクトに存在しないプロパティにアクセスしようとすると、エラーも表示されます。

https://cloud.githubusercontent.com/assets/8976200/25381302/798bab98-29b3-11e7-931e-789e5286fc45.png

"Expression "は "Column "オブジェクトには存在しませんが、ドロップダウンを "Calculated Columns "に切り替えると、上記のステートメントは問題なく動作します。

https://cloud.githubusercontent.com/assets/8976200/25380451/87b160da-29b0-11e7-8e2e-c4e47593007d.png

Dynamic LINQは、すべての標準的な算術演算子、論理演算子、比較演算子をサポートしており、". "表記を使用することで、すべてのオブジェクトのサブプロパティやメソッドにアクセスすることができます。

String.IsNullOrWhitespace(Expression) and not Name.StartsWith("Dummy")
上記のステートメントを計算列、計算テーブル、またはメジャーに適用すると、オブジェクトの名前が「Dummy」というテキストで始まっていない限り、空のDAX式を持つものにフラグを立てます。

LINQを使用すると、オブジェクトのコレクションを扱うこともできます。以下の式をテーブルに適用すると、表示フォルダで整理されていない10以上の列を持つものが見つかります。

Columns.Count(DisplayFolder = "") > 10
LINQメソッドを使用してコレクションを反復処理する場合、LINQメソッドの引数として使用される式は、コレクション内のアイテムに対して評価されます。実際、DisplayFolder は列のプロパティであり、テーブルレベルでは存在しません。

ここでは、Adventure Works の表形式モデルでこのルールが実行されている様子を見てみましょう。Reseller "テーブルが違反していると表示される一方で、"Reseller Sales "は表示されないことに注目してください（後者の列はDisplay Foldersで整理されています）。

https://cloud.githubusercontent.com/assets/8976200/25380809/d9d1c3a4-29b1-11e7-839e-29450ad39c8a.png

LINQメソッド内で親オブジェクトを参照するには、特別な "outerIt "構文を使用します。このルールをテーブルに適用すると、名前がテーブル名で始まらない列を含むものを見つけることができます。

Columns.Any(not Name.StartsWith(outerIt.Name))
このルールをColumnsに直接適用する方がより意味があると思われ、その場合は次のように書かれます。

not Name.StartsWith(Table.Name)
列挙型のプロパティと比較するには、列挙型の値を文字列として渡すだけです。このルールは、名前の末尾が「Key」または「ID」であり、かつ SummarizeBy プロパティが「None」に設定されていないすべての列を検索します。

(Name.EndsWith("Key") or Name.EndsWith("ID")) and SummarizeBy <> "None"
使用されていないオブジェクトの検索
Tabular Modelを構築する際には、何としても高カーダリティのカラムを避けることが重要です。典型的な原因は、誤ってモデルにインポートされたシステムのタイムスタンプ、テクニカルキーなどです。一般的には、モデルには実際に必要なカラムだけを含めるようにしなければなりません。ベストプラクティス・アナライザーが、どのカラムが必要ないかを教えてくれたらいいと思いませんか？

次のルールは、以下のようなカラムを報告します。

...非表示である（または親テーブルが非表示である）。
...どのDAX式からも参照されていない（モデル内のすべてのDAX式（ドリルスルー式やRLSフィルタ式も含む）を考慮する）。
どのようなリレーションシップにも参加していない
他の列の「ソートバイ」列として使用されていない
階層のレベルとして使用されていません。
このBPAルールのダイナミックLINQ式は次のとおりです。

(IsHidden または Table.IsHidden)
and ReferencedBy.Count = 0 
and (not UsedInRelationships.Any())
および (UsedInSortBy.Any() ではない)
および (Not UsedInHierarchies.Any())
同じ手法を使用して、使用されていないメジャーを見つけることができます。メジャーはリレーションシップなどに参加できないので、もう少し簡単です。代わりに、指定されたメジャーを参照している下流のオブジェクトが表示されているかどうかも考慮することで、少し趣向を凝らしてみます。つまり、メジャー [A] がメジャー [B] によって参照されており、メジャー [A] Â および [B] の両方が非表示で、他の DAX 式がこれら 2 つのメジャーを参照していない場合、両方を削除しても安全であることを開発者に知らせる必要があります。

(IsHidden または Table.IsHidden)
でなく、ReferencedBy.AllMeasures.Any(not IsHidden)
およびReferencedBy.AllColumns.Anyではない（IsHiddenではない）
また、ReferencedBy.AllTables.Any（IsHiddenではない）でもありません。
また、ReferencedBy.Roles.Any()ではありません。
オブジェクトの修正
場合によっては、ルールの基準を満たすオブジェクトの問題を自動的に修正することができます。例えば、オブジェクトに簡単なプロパティを設定するだけで済む場合です。次のルールのJSONをよく見てみましょう。

{
    "ID": "fkcolumns_hidden",
    "Name": "Hide foreign key columns" (外部キーカラムを隠す)
    "Category": null,
    "Description": "関係のMany側で使用されるカラムは、非表示にする必要があります。"
    "Severity": 1,
    "Scope": "Column",
    "Expression": "Model.Relations.Any(FromColumn = outerIt) and not IsHidden and not Table.IsHidden",
    "FixExpression": "IsHidden = true",
    "互換性": [
      1200,
      1400
    ],
    "IsValid": false
}
このルールは、リレーションシップ（「Many」/「From」側）で使用されているが、列またはその親テーブルが非表示になっていないすべての列を検出します。ユーザーは関連する（ディメンション）テーブルを使用してデータをフィルタリングする必要があるため、このような列は表示しないことが推奨されます。この場合の修正方法は、列の IsHidden プロパティを true に設定することで、上記の "FixExpression" 文字列がまさにそれを行います。この動作を確認するには、ルールに違反しているオブジェクトを右クリックして、「修正スクリプトの生成」を選択します。これにより、小さなスクリプトがクリップボードに保存され、アドバンスド・スクリプト・エディタに貼り付けることができ、そこから簡単にコードを確認して実行することができます。

https://cloud.githubusercontent.com/assets/8976200/25298489/9035bab6-26f5-11e7-8134-8502daaf4132.png

なお、スクリプト実行後にモデルに加えた変更は、いつでも元に戻すことができます（CTRL+Z）。

この新しいツールに対するフィードバックをお待ちしています。将来的には、Tabular Editorに同梱される普遍的なベストプラクティスのセットを提供することを計画しています。さらに、ベストプラクティス・アナライザーをVisual Studioのプラグインとして提供することも計画しており、Tabular Editorを使用していない方でも利用できるようになります。

ベストプラクティスの公式ルール
Tabular Editorのユーザーに標準的なベストプラクティスを提供するために、ここに新しいGitHubリポジトリが作成され、コミュニティが貢献できるベストプラクティスルールの公開コレクションとして利用されます。あらゆる種類のTabularモデリングで一般的に実行可能であると考えられるルールは、このリポジトリの定期的な「リリース」に含まれます。後日、Tabular EditorはGitHubリポジトリからこれらのルールを自動的に取得できるようになり、BPARules.jsonファイルをリポジトリから手動でダウンロードする必要がなくなります。